package com.mapovich.bbmystatz.ui.statistiche

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import com.mapovich.bbmystatz.data.database.BBMyStatzDatabase
import com.mapovich.bbmystatz.data.model.Statistica
import com.mapovich.bbmystatz.databinding.FragmentStatisticheBinding
import kotlinx.coroutines.launch
import com.faskn.lib.PieChart
import com.faskn.lib.Slice
import com.faskn.lib.buildChart
import com.github.mikephil.charting.charts.LineChart
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.ValueFormatter
import com.mapovich.bbmystatz.R
import com.mapovich.bbmystatz.viewmodel.SharedViewModel


class StatisticsFragment : Fragment() {

    private var _binding: FragmentStatisticheBinding? = null
    private val sharedViewModel: SharedViewModel by activityViewModels()

    // This property is only valid between onCreateView and
    // onDestroyView.
    private val binding get() = _binding!!
    private lateinit var lineChartTiri: LineChart

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val statisticsViewModel =
            ViewModelProvider(this).get(StatisticsViewModel::class.java)

        _binding = FragmentStatisticheBinding.inflate(inflater, container, false)
        val root: View = binding.root

        val spinnerStagione = binding.spinnerStagione
        val spinnerTornei = binding.spinnerTornei
        var initialSeason = spinnerStagione.selectedItem.toString()
        var initialTorneo = spinnerTornei.selectedItem.toString()

        sharedViewModel.selectedSeason.observe(viewLifecycleOwner) { season ->
            // Qui ricevi il valore aggiornato
            initialSeason = season
            val adapter = spinnerStagione.adapter
            val position = (0 until adapter.count).find {
                adapter.getItem(it).toString() == season
            } ?: 0 // Default a 0 se non trova il valore
            spinnerStagione.setSelection(position)
        }

        sharedViewModel.selectedTorneo.observe(viewLifecycleOwner) { torneo ->
            // Qui ricevi il valore aggiornato
            initialTorneo = torneo
            val adapter = spinnerTornei.adapter
            val position = (0 until adapter.count).find {
                adapter.getItem(it).toString() == torneo
            } ?: 0
            spinnerTornei.setSelection(position)


            lifecycleScope.launch {
                updatePercentages(initialSeason, initialTorneo)

                spinnerStagione.onItemSelectedListener =
                    object : AdapterView.OnItemSelectedListener {
                        override fun onItemSelected(
                            parent: AdapterView<*>?,
                            view: View?,
                            position: Int,
                            id: Long
                        ) {
                            val selectedSeason = parent?.getItemAtPosition(position).toString()
                            lifecycleScope.launch {
                                updatePercentages(selectedSeason, initialTorneo)
                                initialSeason = selectedSeason
                            }
                        }

                        override fun onNothingSelected(parent: AdapterView<*>?) {}
                    }

                spinnerTornei.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(
                        parent: AdapterView<*>?,
                        view: View?,
                        position: Int,
                        id: Long
                    ) {
                        val selectedTorneo = parent?.getItemAtPosition(position).toString()
                        lifecycleScope.launch {
                            updatePercentages(initialSeason, selectedTorneo)
                            initialTorneo = selectedTorneo
                        }
                    }

                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }
            }
        }


        return root
    }

    private suspend fun updatePercentages(selectedSeason: String, selectedTorneo: String) {

        val database = BBMyStatzDatabase.getDatabase(requireContext())
        val partitaDao = database.partitaDao()
        var stats: Statistica? = null
        var numeroPartite = 0
        var partiteW = 0
        var partiteL = 0
        var percPartite = ".000"

        // Inizializza il LineChart
        lineChartTiri = binding.lineChartTiri

        // Dati di esempio (array di numeri)
        val valori = partitaDao.getCanestriFattiPerPartita(selectedSeason, selectedTorneo).toFloatArray()


        // Trasforma i dati in Entry
        val entries = valori.mapIndexed { index, value -> Entry(index.toFloat(), value) }


        // Configura il grafico
        setupLineChart(valori)

        // 1. Fetch data for the selected season and torneo
        if (selectedTorneo.equals("TUTTE")){
            stats = partitaDao.getStatsForSeason(selectedSeason)
            numeroPartite = partitaDao.getNumeroPartiteForSeason(selectedSeason)
            partiteW = partitaDao.getPartiteVintePerSeason(selectedSeason, selectedTorneo)
            partiteL = partitaDao.getPartitePersePerSeason(selectedSeason, selectedTorneo)
            percPartite = partitaDao.getIndiceVittoriePerSeason(selectedSeason, selectedTorneo)

        }
        else {
            stats = partitaDao.getStatsForSeasonTorneo(selectedSeason, selectedTorneo)
            numeroPartite = partitaDao.getNumeroPartiteForSeasonTorneo(selectedSeason, selectedTorneo)
            partiteW = partitaDao.getPartiteVintePerSeason(selectedSeason, selectedTorneo)
            partiteL = partitaDao.getPartitePersePerSeason(selectedSeason, selectedTorneo)
            percPartite = partitaDao.getIndiceVittoriePerSeason(selectedSeason, selectedTorneo)
        }
        // 2. Calculate percentages
        if (stats.tiriDa2Tentati != 0) {
            val percentualeTiriDa2 =
                ((stats.tiriDa2Fatti.toFloat() / stats.tiriDa2Tentati.toFloat())*100).toInt()

            val textViewTiriDa2Fatti = binding.textTiriDa2Fatti

            val puntiTotali = stats.tiriDa2Fatti*2+stats.tiriLiberiFatti+stats.tiriDa3Fatti*3
            // Gestione divisione per zero
            val puntiPerPartita = if (numeroPartite > 0) {
                puntiTotali.toDouble() / numeroPartite
            } else {
                0.0
            }
            textViewTiriDa2Fatti.text = String.format("%.1f pp", puntiPerPartita)

            val textViewPercentualeTiriDa2 = binding.textTiriDa2Percentuale
            textViewPercentualeTiriDa2.text = "$percentualeTiriDa2%"


            val valori = arrayListOf(
                Slice(
                    percentualeTiriDa2.toFloat(),
                    R.color.teal_200,
                    "Tiri a segno"
                ),
                Slice(
                    (100 - percentualeTiriDa2).toFloat(),
                    R.color.teal_700,
                    "Tiri mancati"
                ))

         }
        else {
            binding.textTiriDa2Fatti.text = "0/0"
            binding.textTiriDa2Percentuale.text = "0%"
        }


        if (numeroPartite != 0) {

            val assistPerPartita = stats.assist.toFloat() / numeroPartite
            binding.numeroAssistPp.text = String.format("%.1f pp", assistPerPartita)

            val rimbalziPerPartita = stats.rimbalzi.toFloat() / numeroPartite
            binding.numeroRimbalziPp.text = String.format("%.1f pp", rimbalziPerPartita)

            val minutiPerPartita = stats.minutiGiocati.toFloat() / numeroPartite
            binding.minutiGiocatiPp.text = String.format("%.1f pp", minutiPerPartita)

            binding.partiteL.text = partiteL.toString()+" L"
            binding.partiteW.text = partiteW.toString()+" W"
            binding.partiteStat.text = percPartite

        }
        else {
            binding.numeroAssistPp.text = "0 pp"
            binding.numeroRimbalziPp.text = "0 pp"
            binding.minutiGiocatiPp.text = "0 pp"

            val valori = arrayListOf(
                Slice(
                    0.toFloat(),
                    R.color.teal_200,
                    "Tiri a segno"
                ),
                Slice(
                    100.toFloat(),
                    R.color.teal_700,
                    "Tiri mancati"
                ))

            // Kotlin DSL example
            val pieChartDSL = buildChart {
                slices { valori }
                sliceWidth { 80f }
                sliceStartPoint { 0f }
                clickListener { angle, index ->
                    // ...
                }
            }



        }


    }

    private fun setupLineChart(valori: FloatArray) {
        // Converti l'array in una lista di Entry
        val entries = valori.mapIndexed { index, value ->
            Entry(index.toFloat() + 1, value) // Indice come X, valore come Y
        }

        // Crea il dataset
        val dataSet = LineDataSet(entries, "").apply {
            color = resources.getColor(android.R.color.holo_blue_dark, null)
            lineWidth = 2f
            circleRadius = 4f
            setCircleColor(resources.getColor(android.R.color.holo_red_dark, null))
            valueTextColor = resources.getColor(android.R.color.black, null)
        }

        // Aggiungi il dataset al grafico
        lineChartTiri.data = LineData(dataSet)

        // Configura il grafico
        lineChartTiri.description.isEnabled = false
        lineChartTiri.legend.isEnabled = false
        lineChartTiri.xAxis.setDrawGridLines(false)
        lineChartTiri.axisRight.isEnabled = false

        // Configura l'asse X per mostrare solo numeri interi
        lineChartTiri.xAxis.valueFormatter = object : ValueFormatter() {
            override fun getFormattedValue(value: Float): String {
                return value.toInt().toString() // Mostra solo numeri interi
            }
        }
        lineChartTiri.xAxis.granularity = 1f // Forza i passi di 1

        // Configura l'asse Y per mostrare solo numeri interi
        lineChartTiri.axisLeft.valueFormatter = object : ValueFormatter() {
            override fun getFormattedValue(value: Float): String {
                return value.toInt().toString() // Mostra solo numeri interi
            }
        }
        lineChartTiri.axisLeft.granularity = 1f // Forza i passi di 1

        // Aggiorna il grafico
        lineChartTiri.invalidate()
    }


    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}